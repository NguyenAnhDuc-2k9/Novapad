pub async fn fetch_article_text(
    url: &str,
    fallback_title: &str,
    fallback_description: &str,
) -> Result<String, String> {
    let start_total = Instant::now();
    let url_str = normalize_url(url);
    if url_str.is_empty() { return Err("Empty URL".to_string()); }

    log_debug(&format!("rss_article_fetch starting via curl-impersonate url=\"{url_str}\""));
    let url_for_curl = url_str.clone();
    let bytes_res = tokio::task::spawn_blocking(move || {
        crate::curl_client::fetch_url_impersonated(&url_for_curl).map_err(|e| e.to_string())
    }).await.map_err(|e| e.to_string())?;

    let html = match bytes_res {
        Ok(bytes) => {
            let s = String::from_utf8_lossy(&bytes).to_string();
            // DEBUG: Salva l'HTML grezzo in un file vicino all'exe
            if let Ok(mut exe_path) = std::env::current_exe() {
                exe_path.set_file_name("debug_last_fetch.txt");
                if let Err(e) = std::fs::write(exe_path, &s) {
                    log_debug(&format!("rss_article_fetch debug_save_failed: {e}"));
                }
            }
            s
        }
        Err(err) => {
            log_debug(&format!("rss_article_fetch curl_failed url=\"{url_str}\" error=\"{err}\""));
            return Err(err);
        }
    };

    let article = reader::reader_mode_extract(&html).unwrap_or(reader::ArticleContent {
        title: fallback_title.to_string(),
        content: fallback_description.to_string(),
        excerpt: String::new(),
    });
    log_debug(&format!("rss_article_fetch_done ms={} url=\"{url_str}\"", start_total.elapsed().as_millis()));
    Ok(format!("{}\n\n{}", article.title, article.content))
}
